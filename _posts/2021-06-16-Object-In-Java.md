---
layout: post
title: "[20210616] Object in java"
date: 2021-06-16 21:23
last_modified_at: 2021-06-16 21:23
tags: [java]
toc: true
---

> java의 모든 클래스가 상속받는 Object 클래스에 대해 알아보자.

### 인스턴스 소멸 시 반드시 해야 할 일이 있다면 : finalize 메소드

인스턴스가 소멸되기 직전에 자바 가상머신에 의해서 자동으로 호출되는 메소드
하지만, 해당 메소드가 실행되지 않고 프로그램이 종료될 수도 있다.

왜? why?

1. 가비지 컬렉션은 한번도 실행되지 않을 수 있다.

- 빈번한 가비지 컬렉션은 프로그램 성능 문제를 줄 수 있기에, 특정 알고리즘을 통해서 계산된 시간에 가비리 컬렉션이 수행된다.
- 그래서 명시적으로 가비지 컬렉션을 수행시켜야 한다. (System.gc())

2. 명시적으로 가비지 컬렉션을 수행시키 더라도 상황에 따라 인스턴스의 완전한 소멸은 유보될 수 있다.

- 따라서 System.runFinalization()을 별도로 요청해야만 반드시 인스턴스가 소멸시킨다.

### 인스턴스 비교 : equals 메소드

== 연산자는 참조변수의 참조 값을 비교한다.
따라서 인스턴스에 저장되어 있는 값 자체를 비교하려면 별도의 방법을 사용해야함.

### 인스턴스 복사(복제) : clone 메소드

- 인스턴스의 복사를 위해서는 Cloneable 인터페이스를 구현해야 한다. 하지만, Cloneable은 빈 인터페이스이다.
- 하지만 Object.clone이 protected로 선언되어 있어 clone 메소드를 오버라이딩 해서 public으로 변경해야한다.
- 또한 Cloneable 인터페이스를 구현하지않고 clone메소드를 사용하면 CloneNotSupportedException 예외가 발생한다.

clone 메소드를 그냥 사용하게되면 얕은 복사가 된다.
깊은 복사를 위해서는 직접 깊은 복사를 위한 코딩을 해야한다.

(팁) String은 깊은 복사를 하지 않아도된다.
왜? why? String은 변경 불가능한 객체이기 때문!

---

### 출처

윤성우 저, 난 정말 java를 공부한 적이 없다구요